<script src="/javascripts/lib/easeljs.min.js" type="text/javascript"></script>
<script src="/javascripts/lib/tweenjs.min.js" type="text/javascript"></script>
<script src="/javascripts/lib/illuminated.js" type="text/javascript"></script>
<script src='/javascripts/preload.js'></script>
<script src="/javascripts/lib/input.js" type="text/javascript"></script>
<script src='/javascripts/mapUtils.js'></script>
<canvas id='viewport'></canvas>
<canvas id='buffer'></canvas>
<canvas id='lighting'></canvas>

<script>
    var debug = false;

    var FPS = 60
    var TILE_SIZE = 16;
    var MOVE_DISTANCE = 4;
    var CAMERA_WIDTH = 31;
    var CAMERA_HEIGHT = 31;
    var VIEW_DISTANCE = 150;
    var TILES_WIDE;
    var TILES_HIGH;

    var x = 30 * TILE_SIZE;
    var y = 30 * TILE_SIZE;
    var lastViewportRender = {x:-1,y:-1};
    var lastBufferRender = {x:-1, y:-1};
    var lastLightRender = {x:-1, y:-1}

    var solids = [];
    var light;
    var lighting;
    var me;

    var map = {}
    var tilesThatBlockView = [2]

    var INPUT_U = function() { return input.keyboard[87] || input.keyboard[38] ? true:false };
    var INPUT_L = function() { return input.keyboard[65] || input.keyboard[37] ? true:false };
    var INPUT_D = function() { return input.keyboard[83] || input.keyboard[40] ? true:false };
    var INPUT_R = function() { return input.keyboard[68] || input.keyboard[39] ? true:false };

    var tileset;
    var assets = {
        'tileset': '/assets/images/tileset.png',
        'fed'   :  '/assets/images/fed.png',
    }

    $(function() {

        // terrain
        base_canvas = debug ? document.getElementById("buffer") : document.createElement("canvas");
        base_canvas.width = (CAMERA_WIDTH+1) * TILE_SIZE
        base_canvas.height = (CAMERA_HEIGHT+1) * TILE_SIZE
        base_ctx = base_canvas.getContext('2d')

        // lighting
        lighting_canvas = debug ? document.getElementById("lighting") : document.createElement("canvas");
        lighting_canvas.width = (CAMERA_WIDTH+1) * TILE_SIZE
        lighting_canvas.height = (CAMERA_HEIGHT+1) * TILE_SIZE
        lighting_ctx = lighting_canvas.getContext('2d')

        // viewport
        viewport_canvas = document.getElementById("viewport");
        viewport_canvas.width = CAMERA_WIDTH * TILE_SIZE
        viewport_canvas.height = CAMERA_HEIGHT * TILE_SIZE
        viewport_ctx = viewport_canvas.getContext('2d')

        // easeljs stage
        stage_canvas = debug ? document.getElementById("buffer") : document.createElement("canvas");
        stage_canvas.width = (CAMERA_WIDTH+1) * TILE_SIZE
        stage_canvas.height = (CAMERA_HEIGHT+1) * TILE_SIZE
        stage_ctx = stage_canvas.getContext('2d')

        stage_stage = new createjs.Stage(stage_canvas);
        stage_stage.autoClear = true;

        createjs.Ticker.setFPS(FPS);

        light = new illuminated.Lamp({ position: new illuminated.Vec2(x, y),distance: VIEW_DISTANCE});

        lighting = new illuminated.Lighting({ light: light, objects: solids});

        loadMap('level1', function(arr) {

            map.data = arr;
            preload(assets,function() {
                createjs.Ticker.addListener(window);

                me = new Player()
                stage_stage.addChild(me)
                // stage_stage.addChild(new Player({x:200,y:200}))

            });
        })

        $(viewport_canvas).bind('mousemove', function(e) {
            var deltaX = (e.clientX) - viewport_canvas.width/2
            var deltaY = (e.clientY) - viewport_canvas.height/2
            me.rotation = Math.atan2(deltaY, deltaX) / Math.PI * 180 - 90;
            renderViewport(true)
        });

    });

    function loadMap(map, callback) {
        $.get('/assets/maps/' + map + '.json', function(data) {
            var arr = [];
            for(var y = 0;y < data.height; y++) {
                arr[y] = []
                for(var x = 0; x< data.width; x++) {
                    arr[y][x] = data.layers[0].data[y * data.height + x]
                }
            }
            callback(arr)
        })
    }

    function handleInput() {
        if(INPUT_U()) { y-=MOVE_DISTANCE }
        if(INPUT_L()) { x-=MOVE_DISTANCE }
        if(INPUT_D()) { y+=MOVE_DISTANCE }
        if(INPUT_R()) { x+=MOVE_DISTANCE }
    }

    function renderBuffer() {

        if(x==lastBufferRender.x && y==lastBufferRender.y) return;

        var cameraX = Math.floor(x/TILE_SIZE) - Math.floor((CAMERA_WIDTH)/2);
        var cameraY = Math.floor(y/TILE_SIZE) - Math.floor((CAMERA_HEIGHT)/2);

        var walls = [];

        for(var yy=0;yy<CAMERA_HEIGHT+1;yy++) {
            for(var xx=0;xx<CAMERA_WIDTH+1;xx++) {

                var tile = map.data[yy + cameraY][xx + cameraX];
                base_ctx.drawImage(assets.tileset.img,TILE_SIZE*(tile-1),0,TILE_SIZE,TILE_SIZE,xx*TILE_SIZE,yy*TILE_SIZE,TILE_SIZE,TILE_SIZE)

                if($.inArray(tile, tilesThatBlockView) >-1) walls[walls.length] = {x:xx, y:yy}

            }
        }

        lastBufferRender = {x:x, y:y}

        return walls;

    }

    function renderViewport(force) {
        var force = force || false
        if(x == lastViewportRender.x && y == lastViewportRender.y && !force) return false;

        // move everything over by the MOD offset
        $.each(stage_stage.children, function() {
            this.x = this.baseX + x%TILE_SIZE
            this.y = this.baseY + y%TILE_SIZE
        });
        stage_stage.update()

        viewport_ctx.drawImage(base_canvas,x%TILE_SIZE,y%TILE_SIZE, CAMERA_WIDTH * TILE_SIZE, CAMERA_HEIGHT * TILE_SIZE, 0, 0, CAMERA_WIDTH * TILE_SIZE, CAMERA_HEIGHT * TILE_SIZE)
        viewport_ctx.drawImage(stage_canvas,x%TILE_SIZE,y%TILE_SIZE, CAMERA_WIDTH * TILE_SIZE, CAMERA_HEIGHT * TILE_SIZE, 0, 0, CAMERA_WIDTH * TILE_SIZE, CAMERA_HEIGHT * TILE_SIZE)
        viewport_ctx.drawImage(lighting_canvas,x%TILE_SIZE,y%TILE_SIZE, CAMERA_WIDTH * TILE_SIZE, CAMERA_HEIGHT * TILE_SIZE, 0, 0, CAMERA_WIDTH * TILE_SIZE, CAMERA_HEIGHT * TILE_SIZE)

        lastViewportRender = {x:x,y:y}
        return true;
    }

    function processSolids(solids) {
        var objects = []
        for(var w = 0; w< solids.length; w++) {
            objects[objects.length] = new illuminated.RectangleObject({
                topleft: new illuminated.Vec2(solids[w].x * TILE_SIZE, solids[w].y * TILE_SIZE),
                bottomright: new illuminated.Vec2(solids[w].x * TILE_SIZE + TILE_SIZE, solids[w].y * TILE_SIZE + TILE_SIZE)
            });
        }
        return objects;
    }

    function processLights(solids,x,y) {

        if(lastLightRender.x == x && lastLightRender.y ==y) return false;

        light.position.x = (CAMERA_WIDTH+1) * TILE_SIZE / 2 + x
        light.position.y = (CAMERA_HEIGHT+1) * TILE_SIZE / 2 + y

        lighting.objects = solids;

        var touching = lighting.compute((CAMERA_WIDTH+1) * TILE_SIZE, (CAMERA_HEIGHT+1) * TILE_SIZE);

        lighting_ctx.fillStyle = 'rgba(0,0,0,1)'
        lighting_ctx.globalCompositeOperation = 'source-over'
        lighting_ctx.fillRect(0,0,(CAMERA_WIDTH+1) * TILE_SIZE, (CAMERA_HEIGHT+1) * TILE_SIZE)

        lighting_ctx.fillStyle="rgba(0,0,0,.1)";
        lighting_ctx.globalCompositeOperation = 'destination-out'
        lighting_ctx.fillRect(0,0,(CAMERA_WIDTH+1) * TILE_SIZE, (CAMERA_HEIGHT+1) * TILE_SIZE)

        lighting.render(lighting_ctx);
        lighting.render(lighting_ctx);

        lastLightRender = {x:x,y:y}

        lighting_ctx.globalCompositeOperation = 'lighter'
        $.each(solids,function() {
            lighting_ctx.clearRect(this.topleft.x, this.topleft.y,16,16)
            var dist = distance({x:this.topleft.x-x%16, y:this.topleft.y-y%16}, {x:CAMERA_WIDTH * TILE_SIZE / 2,y:CAMERA_HEIGHT * TILE_SIZE / 2}) / VIEW_DISTANCE
            lighting_ctx.fillStyle="rgba(0,0,0," + Math.min(.9,dist) + ")";
            lighting_ctx.fillRect(this.topleft.x, this.topleft.y,16,16)
        });

    }

    function Player(options) {
        var options = options || {}
        var spriteSheet = new createjs.SpriteSheet({
            images: [assets.fed.img],
            frames: {width:32, height:32, regX:16, regY:16},
            animations: {
                alive:{frames:[0], frequency:5}
            }
        });

        bitmap = new createjs.BitmapAnimation(spriteSheet);
        bitmap.gotoAndPlay('alive')
        bitmap.scaleX = .75
        bitmap.scaleY = .75
        bitmap.baseX = options.x || CAMERA_WIDTH*TILE_SIZE/2 + TILE_SIZE /2;
        bitmap.baseY = options.y || CAMERA_HEIGHT*TILE_SIZE/2 + TILE_SIZE /2;
        bitmap.x = options.x || CAMERA_WIDTH*TILE_SIZE/2 + TILE_SIZE /2;
        bitmap.y = options.y || CAMERA_HEIGHT*TILE_SIZE/2 + TILE_SIZE /2;
        return bitmap

    }

    function distance(a,b) {
        return Math.sqrt(Math.pow(a.x-b.x,2) + Math.pow(a.y-b.y,2));
    }

    window.tick = function() {
        handleInput();
        var walls = renderBuffer();
        if(walls) solids = processSolids(walls) || solids;
        processLights(solids, x%TILE_SIZE, y%TILE_SIZE)
        renderViewport()
    }

</script>