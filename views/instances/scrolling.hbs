<script src="/javascripts/lib/easeljs.min.js" type="text/javascript"></script>
<script src="/javascripts/lib/tweenjs.min.js" type="text/javascript"></script>
<script src="/javascripts/lib/illuminated.js" type="text/javascript"></script>
<script src="/javascripts/lib/input.js" type="text/javascript"></script>
<script src='/javascripts/mapUtils.js'></script>
<script src='/assets/map.js'></script>
<style>
    #buffer {
/*        display:none;*/
        border:1px solid blue;
    }
    #viewport {
        border:1px solid purple;
    }
</style>
<canvas id='buffer'></canvas>
<canvas id='viewport'></canvas>

<script>
    var TILE_SIZE = 16;
    var CAMERA_WIDTH = 21;
    var CAMERA_HEIGHT = 11;
    var TILES_WIDE;
    var TILES_HIGH;


    var x = 10 * TILE_SIZE;
    var y = 10 * TILE_SIZE;
    var lastViewportRender = {x:-1,y:-1}
    var lastBufferRender = {x:-1, y:-1}
    var ready = false;
    var mapData = {walls:[],halfWalls:[]}

    var solids = []
    var light;
    var lighting;
    var debug = false

    function parse() {
        for(var y=0;y<map.data.length;y++) {
            var row = map.data[y].split('');
            for(var x=0;x<row.length;x++) {

                var tile = map.data[y][x];

                if(tile=='0') {
                    mapData.walls.push({x:x,y:y})
                }

                if(tile=='1') {
                    mapData.halfWalls.push({x:x,y:y})
                }
            }
        }
        buffer_stage.update();
    }

    INPUT_U = function() { return input.keyboard[87] || input.keyboard[38] ? true:false }
    INPUT_L = function() { return input.keyboard[65] || input.keyboard[37] ? true:false}
    INPUT_D = function() { return input.keyboard[83] || input.keyboard[40] ? true:false }
    INPUT_R = function() { return input.keyboard[68] || input.keyboard[39] ? true:false }

    $(function() {

        buffer_canvas = debug ? document.getElementById("buffer") : document.createElement("canvas");
        buffer_canvas.width = (CAMERA_WIDTH+1) * TILE_SIZE
        buffer_canvas.height = (CAMERA_HEIGHT+1) * TILE_SIZE
        buffer_ctx = buffer_canvas.getContext('2d')
        buffer_stage = new createjs.Stage(buffer_canvas);
        buffer_stage.autoClear = false;

        viewport_canvas = document.getElementById("viewport");
        viewport_canvas.width = CAMERA_WIDTH * TILE_SIZE
        viewport_canvas.height = CAMERA_HEIGHT * TILE_SIZE
        viewport_ctx = viewport_canvas.getContext('2d')

        lighting_canvas = document.createElement("canvas");
        lighting_ctx = lighting_canvas.getContext('2d')
        lighting_canvas.width = (CAMERA_WIDTH+1) * TILE_SIZE
        lighting_canvas.height = (CAMERA_HEIGHT+1) * TILE_SIZE

        createjs.Ticker.addListener(window);
        createjs.Ticker.setFPS(40);

        parse();
        ready = true;

        light = new illuminated.Lamp({
          position: new illuminated.Vec2(x, y),
          distance: 200
        });

        lighting = new illuminated.Lighting({
          light: light,
          objects: solids
        });

    });

    function handleInput() {
        if(INPUT_U()) { y-=4 }
        if(INPUT_L()) { x-=4 }
        if(INPUT_D()) { y+=4 }
        if(INPUT_R()) { x+=4 }
    }

    window.tick = function() {
        handleInput();
        var walls = renderBuffer();
        if(walls) solids = processSolids(walls) || solids;
        processLights(solids, x%TILE_SIZE, y%TILE_SIZE)

        renderViewport()
    }

    function renderBuffer() {
        if(x==lastBufferRender.x && y==lastBufferRender.y) return;

        var cameraX = Math.floor(x/TILE_SIZE) - Math.floor((CAMERA_WIDTH)/2);
        var cameraY = Math.floor(y/TILE_SIZE) - Math.floor((CAMERA_HEIGHT)/2);

        var walls = [];

        for(var yy=0;yy<CAMERA_HEIGHT+1;yy++) {
            for(var xx=0;xx<CAMERA_WIDTH+1;xx++) {

                var tile = map.data[yy + cameraY][xx + cameraX];
                if(tile=='0') {
                    buffer_ctx.fillStyle = '#333'
                    buffer_ctx.fillRect(xx * TILE_SIZE,yy*TILE_SIZE,TILE_SIZE,TILE_SIZE)
                    walls[walls.length] = {x:xx, y:yy}
                } else if(tile=='1') {
                    buffer_ctx.fillStyle = '#666'
                    buffer_ctx.fillRect(xx * TILE_SIZE,yy*TILE_SIZE,TILE_SIZE,TILE_SIZE)
                } else {
                    buffer_ctx.fillStyle = '#fff'
                    buffer_ctx.fillRect(xx * TILE_SIZE,yy*TILE_SIZE,TILE_SIZE,TILE_SIZE)
                }

            }
        }

        lastBufferRender = {x:x, y:y}

        return walls;

    }

    function renderViewport() {
        if(x == lastViewportRender.x && y == lastViewportRender.y) return false;

        viewport_ctx.drawImage(buffer_canvas,x%TILE_SIZE,y%TILE_SIZE, CAMERA_WIDTH * TILE_SIZE, CAMERA_HEIGHT * TILE_SIZE, 0, 0, CAMERA_WIDTH * TILE_SIZE, CAMERA_HEIGHT * TILE_SIZE)
        lastViewportRender = {x:x,y:y}

        return true;
    }

    function processSolids(solids) {
        var objects = []
        for(var w = 0; w< solids.length; w++) {
            objects[objects.length] = new illuminated.RectangleObject({
                topleft: new illuminated.Vec2(solids[w].x * TILE_SIZE, solids[w].y * TILE_SIZE),
                bottomright: new illuminated.Vec2(solids[w].x * TILE_SIZE + TILE_SIZE, solids[w].y * TILE_SIZE + TILE_SIZE)
            });
        }
        return objects;
    }

    function processLights(solids,x,y) {

        light.position.x = (CAMERA_WIDTH+1) * TILE_SIZE / 2 + x
        light.position.y = (CAMERA_HEIGHT+1) * TILE_SIZE / 2 + y

        lighting.objects = solids;

        lighting.compute((CAMERA_WIDTH+1) * TILE_SIZE, (CAMERA_HEIGHT+1) * TILE_SIZE);

        lighting_ctx.fillStyle = 'rgba(0,0,0,1)'
        lighting_ctx.globalCompositeOperation = 'source-over'
        lighting_ctx.fillRect(0,0,(CAMERA_WIDTH+1) * TILE_SIZE, (CAMERA_HEIGHT+1) * TILE_SIZE)

        lighting_ctx.fillStyle="rgba(0,0,0,.1)";
        lighting_ctx.globalCompositeOperation = 'destination-out'
        lighting_ctx.fillRect(0,0,(CAMERA_WIDTH+1) * TILE_SIZE, (CAMERA_HEIGHT+1) * TILE_SIZE)

        lighting.render(lighting_ctx);

        buffer_ctx.drawImage(lighting_canvas,0,0, (CAMERA_WIDTH+1) * TILE_SIZE, (CAMERA_HEIGHT+1) * TILE_SIZE, 0, 0, (CAMERA_WIDTH+1) * TILE_SIZE, (CAMERA_HEIGHT+1) * TILE_SIZE)

    }

</script>